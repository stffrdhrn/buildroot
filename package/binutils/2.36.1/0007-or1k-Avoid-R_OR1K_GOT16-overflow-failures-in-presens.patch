From 1637c2994331cc79b932204a622a5d692e3640d0 Mon Sep 17 00:00:00 2001
From: Stafford Horne <shorne@gmail.com>
Date: Tue, 20 Apr 2021 05:54:50 +0900
Subject: [PATCH 7/6] or1k: Avoid R_OR1K_GOT16 overflow failures in presense of
 R_OR1K_GOT_AHI16

---
 bfd/elf32-or1k.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/bfd/elf32-or1k.c b/bfd/elf32-or1k.c
index 6afacfa57cf..cb207bc3c2a 100644
--- a/bfd/elf32-or1k.c
+++ b/bfd/elf32-or1k.c
@@ -1289,6 +1289,7 @@ or1k_elf_relocate_section (bfd *output_bfd,
   asection *sgot, *splt;
   bfd_vma plt_base, got_base, got_sym_value;
   bfd_boolean ret_val = TRUE;
+  bfd_boolean saw_gotha = FALSE;
 
   if (htab == NULL)
     return false;
@@ -1496,6 +1497,16 @@ or1k_elf_relocate_section (bfd *output_bfd,
 		|| r_type == R_OR1K_GOT_AHI16)
 	      relocation -= got_sym_value;
 
+	    if (r_type == R_OR1K_GOT_AHI16)
+	      saw_gotha = TRUE;
+
+	    /* If we have a R_OR1K_GOT_AHI16 followed by a R_OR1K_GOT_AHI16
+	       relocation we assume the code is doing the right thing to avoid
+	       overflows.  Here we mask the lower 16-bit of the relocation to
+	       avoid overflow validation failures.  */
+	    if (r_type == R_OR1K_GOT16 && saw_gotha)
+	      relocation &= 0xffff;
+
 	  /* Addend should be zero.  */
 	  if (rel->r_addend != 0)
 	    {
-- 
2.26.2

